'''
reproduce.py: part of singularity package, functions to assess
  reproducibility of images

'''

from singularity.cli import Singularity
from singularity.logman import bot
from singularity.utils import (
    get_installdir,
    read_json
)
import datetime
import hashlib
import tarfile
import sys
import os
import re
import io



def get_custom_level(regexp,name=None,description=None):
    '''get_custom_level will generate a custom level for the user, 
    based on a regular expression. If used outside the context of tarsum, the user
    can generate their own named and described filters.
    :param regexp: must be defined, the file filter regular expression
    :param name: optional name for the filter
    :param description: optional description
    '''
    if name is None:
        name = "CUSTOM"
    if description is None:
        description = "This is a custom filter generated by the user."
    return {name:{"description":description,
                  "regexp":regexp}}


def get_level(level):
    return get_levels(level)


def get_levels(level=None):
    '''get_levels returns a dictionary of levels (key) and values (dictionaries with
    descriptions and regular expressions for files) for the user. 
    '''
  
    levels_file = os.path.abspath(os.path.join(get_installdir(),
                                                           'hub',
                                                           'data',
                                                           'reproduce_levels.json'))
    valid_levels = read_json(levels_file)
    level_names = list(valid_levels.keys())

    if level is not None:
        if level.upper() in valid_levels:
            return valid_levels[level]
        else:
            bot.logger.warning("%s is not a valid level. Options are %s",level.upper(),
                                                                           "\n".join(level_names))             
        return None

    return valid_levels


def include_file(member_path,regexp):
    '''include_file will look at a path and determine
    if it matches a regular expression from a level
    '''
    member_path = member_path.replace('.','',1)
    if re.search(regexp,member_path):
        return True
    return False


def get_image_hash(image_path,level=None,regexp=None):
    '''get_image_hash will generate a sha1 hash of an image, depending on a level
    of reproducibility specified by the user. (see function get_levels for descriptions)
    :param level: the level of reproducibility to use, which maps to a set regular
    expression to match particular files/folders in the image. Choices are in notes.
    :param regexp: if defined, the level is ignored and the regular expression used
    instead.

    ::notes

    LEVEL DEFINITIONS
    The level definitions come down to including folders/files in the comparison. 
    The top are the most time intensive (applied to more files), and the bottom
    are quicker and more specific, but don't assess as much of the image. The default
    level, if not specified, is REPLICATE. It is the user's choice where to operate
    on these levels of reproducibility.
    '''    

    # First get a level dictionary, with description and regexp
    if regexp is not None:
        file_filter = get_custom_level(regexp)  

    elif level is not None:
        if level is "IDENTICAL":
            return get_image_file_hash(image_path)
        file_filter = get_level(level)
                
    else:
        file_filter = get_level("REPLICATE")

    cli = Singularity()
    byte_array = cli.export(image_path,pipe=True)
    file_object = io.BytesIO(byte_array)
 
    # Now create a tarfile from the file object
    tar = tarfile.open(mode="r|*", fileobj=file_object) 
    chunk_size = 100*1024
    hasher = hashlib.sha1()
    for member in tar:
        if member.isfile():
            if include_file(member.name,file_filter['regexp']):
                filey = tar.extractfile(member)
                buf = filey.read(chunk_size)
                while buf:
                    hasher.update(buf)
                    buf = filey.read(chunk_size)
    return hasher.hexdigest()


def get_content_hashes(image_path,level=None,regexp=None):
    '''get_content_hashes is like get_image_hash, but it returns a complete dictionary 
    of file names (keys) and their respective hashes (values). This function is intended
    for more research purposes and was used to generate the levels in the first place
    '''    

    # First get a level dictionary, with description and regexp
    if regexp is not None:
        file_filter = get_custom_level(regexp)  

    elif level is not None:
        file_filter = get_level(level)
                
    else:
        file_filter = get_level("REPLICATE")

    cli = Singularity()
    byte_array = cli.export(image_path,pipe=True)
    file_object = io.BytesIO(byte_array)
 
    # Now create a tarfile from the file object
    tar = tarfile.open(mode="r|*", fileobj=file_object) 
    chunk_size = 100*1024
    digest = dict()
    for member in tar:
        if member.isfile():
            if include_file(member.name,file_filter['regexp']):
                buf = member.tobuf()
                hasher = hashlib.sha1()
                hasher.update(buf)
                digest[member.name] = hasher.hexdigest()
    return digest


def get_image_file_hash(image_path):
    '''get_image_hash will return an md5 hash of the file based on a criteria level.
    :param level: one of LOW, MEDIUM, HIGH
    :param image_path: full path to the singularity image
    '''
    hasher = hashlib.sha1()
    with open(image_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hasher.update(chunk)
    return hasher.hexdigest()
