'''
reproduce.py: part of singularity package, functions to assess
  reproducibility of images

'''

from singularity.cli import Singularity
from singularity.logman import bot
from singularity.utils import (
    get_installdir,
    read_json
)
import datetime
import hashlib
import tarfile
import sys
import os
import re
import io


def assess_replication(image_file1,image_file2,version=None):
    '''assess_replications will compare two images on each level of 
    reproducibility,
    '''
    levels = get_levels(version=version)
    report = dict()
    for level_name, values in levels.items():
        hash1 = get_image_hash(image_path=image_file1,
                               level=level_name)
        hash2 = get_image_hash(image_path=image_file2,
                               level=level_name)
        if hash1 == hash2:
            report[level_name] = True
        else:
            report[level_name] = False
    return report


def assess_differences(image_file1,image_file2,level=None,version=None):
    '''assess_replications will compare two images on each level of 
    reproducibility,
    '''
    levels = get_levels(version=version)
    if level is None:
        level = "IDENTICAL"

    if level not in list(levels.keys()):
        bot.logger.error("%s is not a valid level. See get_levels().",level)
        sys.exit(1)

    different = []
    same = []
    setdiff = []

    # Compare the dictionary of file:hash between two images
    hashes1 = get_content_hashes(image_path=image_file1,level=level)
    hashes2 = get_content_hashes(image_path=image_file2,level=level)
    for file_name,hash_value in hashes1.items():
        if file_name in hashes2:
            if hashes2[file_name] == hashes1[file_name]:
                same.append(file_name)
            else:
                different.append(file_name)
        else:
            setdiff.append(file_name)

    report = {'missing':setdiff,
              'same':same,
              'different':different}

    return report


def get_custom_level(regexp=None,description=None,skip_files=None,include_files=None):
    '''get_custom_level will generate a custom level for the user, 
    based on a regular expression. If used outside the context of tarsum, the user
    can generate their own named and described filters.
    :param regexp: must be defined, the file filter regular expression
    :param description: optional description
    '''
    if regexp == None:
        regexp = "."
    if description is None:
        description = "This is a custom filter generated by the user."
    
    custom = {"description":description,
              "regexp":regexp}

    # Include extra files?
    if include_files is not None:
        if not isinstance(include_files,list):
            include_files = [include_files]
        custom['include_files'] = include_files

    # Skip files?
    if skip_files is not None:
        if not isinstance(skip_files,list):
            skip_files = [skip_files]
        custom['skip_files'] = skip_files

    return custom


def get_level(level,version=None,include_files=None,skip_files=None):
    '''get_level returns a single level, with option to customize files
    added and skipped.
    '''

    levels = get_levels(version=version)
    level_names = list(levels.keys())

    if level.upper() in level_names:
        level = levels[level]
    else:
        bot.logger.warning("%s is not a valid level. Options are %s",level.upper(),
                                                                    "\n".join(levels))             
        return None

    # Add additional files to skip or remove, if defined
    if skip_files is not None:
        level = modify_level(level,'skip_files',skip_files)
    if include_files is not None:
        level = modify_level(level,'include_files',include_files)

    return level


def modify_level(level,field,values,append=True):
    '''modify level is intended to add / modify a content type.
    Default content type is list, meaning the entry is appended.
    If you set append to False, the content will be overwritten
    For any other content type, the entry is overwritten.
    '''
    field = field.lower()
    valid_fields = ['regexp','skip_files','include_files']
    if field not in valid_fields:
        bot.logger.warning("%s is not a valid field, skipping. Choices are %s",field,",".join(valid_fields))
        return level
    if append:
        if not isinstance(values,list):
            values = [values]
        if field in level:
            level[field] = level[field] + values
        else:
            level[field] = values
    else:
        level[field] = values
    return level       


def get_levels(version=None):
    '''get_levels returns a dictionary of levels (key) and values (dictionaries with
    descriptions and regular expressions for files) for the user. 
    :param version: the version of singularity to use (default is 2.2)
    :param include_files: files to add to the level, only relvant if
    '''
    if version is None:
        version = "2-2"  
    version = str(version).replace('.','-')
    valid_versions = ['2-2','2-3']
    if version not in valid_versions:
        bot.logger.error("Unsupported version %s, valid versions are %s",version,",".join(valid_versions))

    levels_file = os.path.abspath(os.path.join(get_installdir(),
                                                           'hub',
                                                           'data',
                                                           'reproduce_levels.json'))
    return read_json(levels_file)


def include_file(member_path,file_filter):
    '''include_file will look at a path and determine
    if it matches a regular expression from a level
    '''
    member_path = member_path.replace('.','',1)

    # Does the filter skip it explicitly?
    if "skip_files" in file_filter:
        if member_path in file_filter['skip_files']:
            return False

    # Include explicitly?
    if "include_files" in file_filter:
        if member_path in file_filter['include_files']:
            return True

    # Regular expression?
    if "regexp" in file_filter:
        if re.search(file_filter["regexp"],member_path):
            return True
    return False


def get_image_hashes(image_path,version=None):
    '''get_image_hashes returns the hash for an image across all levels. This is the quickest,
    easiest way to define a container's reproducibility on each level.
    '''
    levels = get_levels(version=version)
    hashes = dict()
    for level_name,level_filter in levels.items():
        hashes[level_name] = get_image_hash(image_path,
                                            level_filter=level_filter)
    return hashes



def get_image_hash(image_path,level=None,level_filter=None,include_files=None,skip_files=None,version=None):
    '''get_image_hash will generate a sha1 hash of an image, depending on a level
    of reproducibility specified by the user. (see function get_levels for descriptions)
    the user can also provide a level_filter manually with level_filter (for custom levels)
    :param level: the level of reproducibility to use, which maps to a set regular
    expression to match particular files/folders in the image. Choices are in notes.
    :param skip_files: an optional list of files to skip
    :param include_files: an optional list of files to keep (only if level not defined)
    :param version: the version to use. If not defined, default is 2.3

    ::notes

    LEVEL DEFINITIONS
    The level definitions come down to including folders/files in the comparison. 
    The top are the most time intensive (applied to more files), and the bottom
    are quicker and more specific, but don't assess as much of the image. The default
    level, if not specified, is REPLICATE. It is the user's choice where to operate
    on these levels of reproducibility.
    '''    

    # First get a level dictionary, with description and regexp
    if level_filter is not None:
        file_filter = level_filter

    elif level is None:
        file_filter = get_level("REPLICATE",
                                version=version,
                                include_files=include_files,
                                skip_files=skip_files)

    else:
        file_filter = get_level(level,version=version,
                                skip_files=skip_files,
                                include_files=include_files)
                
    tar = get_memory_tar(image_path)
    hasher = hashlib.sha1()
    for member in tar:
        if member.isfile():
            if include_file(member.name,file_filter):
                buf = member.tobuf()
                hasher.update(buf)
    return hasher.hexdigest()


def get_content_hashes(image_path,level=None,regexp=None,include_files=None,skip_files=None,version=None):
    '''get_content_hashes is like get_image_hash, but it returns a complete dictionary 
    of file names (keys) and their respective hashes (values). This function is intended
    for more research purposes and was used to generate the levels in the first place
    '''    
    # First get a level dictionary, with description and regexp
    if level is None:
        if regexp is not None or include_files is not None or skip_files is not None:
            file_filter = get_custom_level(regexp=regexp,
                                           include_files=include_files,
                                           skip_files=skip_files)  
        else:
            file_filter = get_level("REPLICATE",version=version,
                                    skip_files=skip_files,
                                    include_files=include_files)

    else:
        file_filter = get_level(level,version=version,
                                skip_files=skip_files,
                                include_files=include_files)

    tar = get_memory_tar(image_path)
    chunk_size = 100*1024
    digest = dict()
    for member in tar:
        if member.isfile():
            if include_file(member.name,file_filter):
                buf = member.tobuf()
                hasher = hashlib.sha1()
                hasher.update(buf)
                digest[member.name] = hasher.hexdigest()
    return digest


def get_image_file_hash(image_path):
    '''get_image_hash will return an md5 hash of the file based on a criteria level.
    :param level: one of LOW, MEDIUM, HIGH
    :param image_path: full path to the singularity image
    '''
    hasher = hashlib.sha1()
    with open(image_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hasher.update(chunk)
    return hasher.hexdigest()


def get_memory_tar(image_path):
    '''get an in memory tar of an image (does not require sudo!'''
    cli = Singularity()
    byte_array = cli.export(image_path,pipe=True)
    file_object = io.BytesIO(byte_array)
    return tarfile.open(mode="r|*", fileobj=file_object) 
