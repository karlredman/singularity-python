'''
reproduce.py: part of singularity package, functions to assess
  reproducibility of images

'''

from singularity.cli import Singularity
from singularity.logman import bot
from singularity.utils import (
    get_installdir,
    read_json
)
import datetime
import hashlib
import tarfile
import sys
import os
import re
import io


def assess_replication(image_file1,image_file2,version=None):
    '''assess_replications will compare two images on each level of 
    reproducibility,
    '''
    levels = get_levels(version=version)
    report = dict()
    for level_name, values in levels.items():
        hash1 = get_image_hash(image_path=image_file1,
                               level=level_name)
        hash2 = get_image_hash(image_path=image_file2,
                               level=level_name)
        if hash1 == hash2:
            report[level_name] = True
        else:
            report[level_name] = False
    return report


def assess_differences(image_file1,image_file2,level=None,version=None):
    '''assess_replications will compare two images on each level of 
    reproducibility,
    '''
    levels = get_levels(version=version)
    if level is None:
        level = "IDENTICAL"

    if level not in list(levels.keys()):
        bot.logger.error("%s is not a valid level. See get_levels().",level)
        sys.exit(1)

    different = []
    same = []
    setdiff = []

    # Compare the dictionary of file:hash between two images
    hashes1 = get_content_hashes(image_path=image_file1,level=level)
    hashes2 = get_content_hashes(image_path=image_file2,level=level)
    for file_name,hash_value in hashes1.items():
        if file_name in hashes2:
            if hashes2[file_name] == hashes1[file_name]:
                same.append(file_name)
            else:
                different.append(file_name)
        else:
            setdiff.append(file_name)

    report = {'missing':setdiff,
              'same':same,
              'different':different}

    return report


def get_custom_level(regexp,name=None,description=None):
    '''get_custom_level will generate a custom level for the user, 
    based on a regular expression. If used outside the context of tarsum, the user
    can generate their own named and described filters.
    :param regexp: must be defined, the file filter regular expression
    :param name: optional name for the filter
    :param description: optional description
    '''
    if name is None:
        name = "CUSTOM"
    if description is None:
        description = "This is a custom filter generated by the user."
    return {name:{"description":description,
                  "regexp":regexp}}


def get_level(level):
    return get_levels(level)


def get_levels(level=None,version=None):
    '''get_levels returns a dictionary of levels (key) and values (dictionaries with
    descriptions and regular expressions for files) for the user. 
    :param version: the version of singularity to use (default is 2.2)
    '''
    if version is None:
        version = "2-2"  
    version = str(version).replace('.','-')
    valid_versions = ['2-2','2-3']
    if version not in valid_versions:
        bot.logger.error("Unsupported version %s, valid versions are %s",version,",".join(valid_versions))

    levels_file = os.path.abspath(os.path.join(get_installdir(),
                                                           'hub',
                                                           'data',
                                                           'reproduce_levels.json'))
    valid_levels = read_json(levels_file)
    level_names = list(valid_levels.keys())

    if level is not None:
        if level.upper() in valid_levels:
            return valid_levels[level]
        else:
            bot.logger.warning("%s is not a valid level. Options are %s",level.upper(),
                                                                           "\n".join(level_names))             
        return None

    return valid_levels


def include_file(member_path,file_filter):
    '''include_file will look at a path and determine
    if it matches a regular expression from a level
    '''
    member_path = member_path.replace('.','',1)

    # Does the filter skip it explicitly?
    if "skip_files" in file_filter:
        if member_path in file_filter['skip_files']:
            return False

    # Include explicitly?
    if "include_files" in file_filter:
        if member_path in file_filter['include_files']:
            return True

    # Regular expression?
    if "regexp" in file_filter:
        if re.search(file_filter["regexp"],member_path):
            return True
    return False



def get_image_hash(image_path,level=None,regexp=None,include_files=None,skip_files=None):
    '''get_image_hash will generate a sha1 hash of an image, depending on a level
    of reproducibility specified by the user. (see function get_levels for descriptions)
    :param level: the level of reproducibility to use, which maps to a set regular
    expression to match particular files/folders in the image. Choices are in notes.
    :param regexp: if defined, the level is ignored and the regular expression used
    instead.
    :param skip_files: an optional list of files to skip
    :param include_files: an optional list of files to keep (only if level not defined)

    ::notes

    LEVEL DEFINITIONS
    The level definitions come down to including folders/files in the comparison. 
    The top are the most time intensive (applied to more files), and the bottom
    are quicker and more specific, but don't assess as much of the image. The default
    level, if not specified, is REPLICATE. It is the user's choice where to operate
    on these levels of reproducibility.
    '''    

    # First get a level dictionary, with description and regexp
    if level is None:
        if regexp is not None or include_files is not None or skip_files is not None:
            file_filter = get_custom_level(regexp=regexp,
                                           include_files=include_files,
                                           skip_files=skip_files)  
        else:
            file_filter = get_level("REPLICATE")

    else:
        file_filter = get_level(level)
                

    cli = Singularity()
    byte_array = cli.export(image_path,pipe=True)
    file_object = io.BytesIO(byte_array)
 
    # Now create a tarfile from the file object
    tar = tarfile.open(mode="r|*", fileobj=file_object) 
    hasher = hashlib.sha1()
    for member in tar:
        if member.isfile():
            if include_file(member.name,file_filter):
                buf = member.tobuf()
                hasher.update(buf)
    return hasher.hexdigest()


def get_content_hashes(image_path,level=None,regexp=None,include_files=None,skip_files=None):
    '''get_content_hashes is like get_image_hash, but it returns a complete dictionary 
    of file names (keys) and their respective hashes (values). This function is intended
    for more research purposes and was used to generate the levels in the first place
    '''    
    # First get a level dictionary, with description and regexp
    if level is None:
        if regexp is not None or include_files is not None or skip_files is not None:
            file_filter = get_custom_level(regexp=regexp,
                                           include_files=include_files,
                                           skip_files=skip_files)  
        else:
            file_filter = get_level("REPLICATE")

    else:
        file_filter = get_level(level)

    cli = Singularity()
    byte_array = cli.export(image_path,pipe=True)
    file_object = io.BytesIO(byte_array)
 
    # Now create a tarfile from the file object
    tar = tarfile.open(mode="r|*", fileobj=file_object) 
    chunk_size = 100*1024
    digest = dict()
    for member in tar:
        if member.isfile():
            if include_file(member.name,file_filter):
                buf = member.tobuf()
                hasher = hashlib.sha1()
                hasher.update(buf)
                digest[member.name] = hasher.hexdigest()
    return digest


def get_image_file_hash(image_path):
    '''get_image_hash will return an md5 hash of the file based on a criteria level.
    :param level: one of LOW, MEDIUM, HIGH
    :param image_path: full path to the singularity image
    '''
    hasher = hashlib.sha1()
    with open(image_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hasher.update(chunk)
    return hasher.hexdigest()
