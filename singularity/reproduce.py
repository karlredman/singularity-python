'''
reproduce.py: part of singularity package, functions to assess
  reproducibility of images

'''

from singularity.cli import Singularity
from singularity.logman import bot
from singularity.utils import (
    get_installdir,
    read_json
)
import datetime
import hashlib
import tarfile
import sys
import os
import re
import io


def assess_replication(image_file1,image_file2,version=None):
    '''assess_replications will compare two images on each level of 
    reproducibility,
    '''
    levels = get_levels(version=version)
    report = dict()
    for level_name, values in levels.items():
        hash1 = get_image_hash(image_path=image_file1,
                               level=level_name)
        hash2 = get_image_hash(image_path=image_file2,
                               level=level_name)
        if hash1 == hash2:
            report[level_name] = True
        else:
            report[level_name] = False
    return report


def assess_differences(image_file1,image_file2,levels=None,version=None,include_same=False):
    '''assess_differences will compare two images on each level of 
    reproducibility, returning for each level a dictionary with files
    that are the same, different, and an overall score.
    :param include_same: if True, also include list of intersect_same files (default False)
    '''

    if levels is None:
        levels = get_levels(version=version)

    reports = dict()
    scores = dict()

    for level_name, level_filter in levels.items():
        different = []
        same = []
        setdiff = []

        # Compare the dictionary of file:hash between two images
        hashes1 = get_content_hashes(image_path=image_file1,level_filter=level_filter)
        hashes2 = get_content_hashes(image_path=image_file2,level_filter=level_filter)        
        files = list(set(list(hashes1.keys()) + list(hashes2.keys())))

        for file_name in files:

            # If it's not in one or the other
            if file_name not in hashes1 or file_name not in hashes2:
                setdiff.append(file_name)

            else:
                if hashes2[file_name] == hashes1[file_name]:
                    same.append(file_name)
                else:
                    different.append(file_name)

        report = {'difference': setdiff,
                  'intersect_different': different}

        if include_same == True:
            report['intersect_same'] = same

        # Calculated score is number of same / total
        if len(files) == 0:
            scores[level_name] = 0
        else:
            scores[level_name] = len(same)/float(len(files)) 
        reports[level_name] = report
    reports['scores'] = scores
    return reports


def get_custom_level(regexp=None,description=None,skip_files=None,include_files=None):
    '''get_custom_level will generate a custom level for the user, 
    based on a regular expression. If used outside the context of tarsum, the user
    can generate their own named and described filters.
    :param regexp: must be defined, the file filter regular expression
    :param description: optional description
    '''
    if regexp == None:
        regexp = "."
    if description is None:
        description = "This is a custom filter generated by the user."
    
    custom = {"description":description,
              "regexp":regexp}

    # Include extra files?
    if include_files is not None:
        if not isinstance(include_files,list):
            include_files = [include_files]
        custom['include_files'] = include_files

    # Skip files?
    if skip_files is not None:
        if not isinstance(skip_files,list):
            skip_files = [skip_files]
        custom['skip_files'] = skip_files

    return custom


def get_level(level,version=None,include_files=None,skip_files=None):
    '''get_level returns a single level, with option to customize files
    added and skipped.
    '''

    levels = get_levels(version=version)
    level_names = list(levels.keys())

    if level.upper() in level_names:
        level = levels[level]
    else:
        bot.logger.warning("%s is not a valid level. Options are %s",level.upper(),
                                                                    "\n".join(levels))             
        return None

    # Add additional files to skip or remove, if defined
    if skip_files is not None:
        level = modify_level(level,'skip_files',skip_files)
    if include_files is not None:
        level = modify_level(level,'include_files',include_files)

    return level


def modify_level(level,field,values,append=True):
    '''modify level is intended to add / modify a content type.
    Default content type is list, meaning the entry is appended.
    If you set append to False, the content will be overwritten
    For any other content type, the entry is overwritten.
    '''
    field = field.lower()
    valid_fields = ['regexp','skip_files','include_files']
    if field not in valid_fields:
        bot.logger.warning("%s is not a valid field, skipping. Choices are %s",field,",".join(valid_fields))
        return level
    if append:
        if not isinstance(values,list):
            values = [values]
        if field in level:
            level[field] = level[field] + values
        else:
            level[field] = values
    else:
        level[field] = values
    return level       


def get_levels(version=None):
    '''get_levels returns a dictionary of levels (key) and values (dictionaries with
    descriptions and regular expressions for files) for the user. 
    :param version: the version of singularity to use (default is 2.2)
    :param include_files: files to add to the level, only relvant if
    '''
    valid_versions = ['2.3','2.2']

    if version is None:
        version = "2.3"  
    version = str(version)

    if version not in valid_versions:
        bot.logger.error("Unsupported version %s, valid versions are %s",version,",".join(valid_versions))

    levels_file = os.path.abspath(os.path.join(get_installdir(),
                                                           'hub',
                                                           'data',
                                                           'reproduce_levels.json'))
    levels = read_json(levels_file)
    if version == "2.2":
        # Labels not added until 2.3
        del levels['LABELS']
    return levels


def include_file(member_path,file_filter):
    '''include_file will look at a path and determine
    if it matches a regular expression from a level
    '''
    member_path = member_path.replace('.','',1)

    # Does the filter skip it explicitly?
    if "skip_files" in file_filter:
        if member_path in file_filter['skip_files']:
            return False

    # Include explicitly?
    if "include_files" in file_filter:
        if member_path in file_filter['include_files']:
            return True

    # Regular expression?
    if "regexp" in file_filter:
        if re.search(file_filter["regexp"],member_path):
            return True
    return False


def assess_content(member_path,file_filter):
    '''Determine if the filter wants the file to be read for content.
    In the case of yes, we would then want to add the content to the
    hash and not the file object.
    '''
    member_path = member_path.replace('.','',1)

    if "assess_content" in file_filter:
        if member_path in file_filter['assess_content']:
            return True
    return False


def get_image_hashes(image_path,version=None,levels=None,verbose=False):
    '''get_image_hashes returns the hash for an image across all levels. This is the quickest,
    easiest way to define a container's reproducibility on each level.
    '''
    if levels is None:
        levels = get_levels(version=version)
    hashes = dict()
    for level_name,level_filter in levels.items():
        hashes[level_name] = get_image_hash(image_path,
                                            level_filter=level_filter,
                                            verbose=verbose)
    return hashes


def get_image_hash(image_path,level=None,level_filter=None,verbose=False,
                   include_files=None,skip_files=None,version=None):
    '''get_image_hash will generate a sha1 hash of an image, depending on a level
    of reproducibility specified by the user. (see function get_levels for descriptions)
    the user can also provide a level_filter manually with level_filter (for custom levels)
    :param level: the level of reproducibility to use, which maps to a set regular
    expression to match particular files/folders in the image. Choices are in notes.
    :param skip_files: an optional list of files to skip
    :param include_files: an optional list of files to keep (only if level not defined)
    :param verbose: print out files that are included, default False
    :param version: the version to use. If not defined, default is 2.3

    ::notes

    LEVEL DEFINITIONS
    The level definitions come down to including folders/files in the comparison. For files
    that Singularity produces on the fly that might be different (timestamps) but equal content
    (eg for a replication) we hash the content ("assess_content") instead of the file.
    '''    

    # First get a level dictionary, with description and regexp
    if level_filter is not None:
        file_filter = level_filter

    elif level is None:
        file_filter = get_level("RECIPE",
                                version=version,
                                include_files=include_files,
                                skip_files=skip_files)

    else:
        file_filter = get_level(level,version=version,
                                skip_files=skip_files,
                                include_files=include_files)
                
    cli = Singularity()
    tar = get_memory_tar(image_path)
    hasher = hashlib.md5()
    for member in tar:
        if member.isfile() or member.islnk() or member.issym():
            if assess_content(member.name,file_filter):
                if verbose == True:
                    print('Including %s' %(member.name))
                member_name = member.name.replace('.','',1)
                content = cli.execute(image_path,'cat %s' %(member_name))
                if not isinstance(content,bytes):
                    content = bytes(content)
                hasher.update(content) 
            elif include_file(member.name,file_filter):
                buf = member.tobuf()
                hasher.update(buf)
    return hasher.hexdigest()


def get_content_hashes(image_path,level=None,regexp=None,include_files=None,
                       level_filter=None,skip_files=None,version=None,verbose=False):
    '''get_content_hashes is like get_image_hash, but it returns a complete dictionary 
    of file names (keys) and their respective hashes (values). This function is intended
    for more research purposes and was used to generate the levels in the first place
    '''    
    if level_filter is not None:
        file_filter = level_filter

    elif level is None:
        file_filter = get_level("RECIPE",version=version,
                                skip_files=skip_files,
                                include_files=include_files)

    else:
        file_filter = get_level(level,version=version,
                                skip_files=skip_files,
                                include_files=include_files)

    tar = get_memory_tar(image_path)
    chunk_size = 100*1024
    cli = Singularity()
    digest = dict()
    for member in tar:
        if member.isfile() or member.islnk() or member.issym():
            if assess_content(member.name,file_filter):
                hasher = hashlib.md5()
                if verbose == True:
                    print('Including %s' %(member.name))
                member_name = member.name.replace('.','',1)
                content = cli.execute(image_path,'cat %s' %(member_name))
                if not isinstance(content,bytes):
                    content = bytes(content)
                hasher.update(content) 
                digest[member.name] = hasher.hexdigest()
            elif include_file(member.name,file_filter):
                hasher = hashlib.md5()
                buf = member.tobuf()
                hasher.update(buf)
                digest[member.name] = hasher.hexdigest()
    return digest


def get_image_file_hash(image_path):
    '''get_image_hash will return an md5 hash of the file based on a criteria level.
    :param level: one of LOW, MEDIUM, HIGH
    :param image_path: full path to the singularity image
    '''
    hasher = hashlib.md5()
    with open(image_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hasher.update(chunk)
    return hasher.hexdigest()


def get_memory_tar(image_path):
    '''get an in memory tar of an image (does not require sudo!'''
    cli = Singularity()
    byte_array = cli.export(image_path,pipe=True)
    file_object = io.BytesIO(byte_array)
    return tarfile.open(mode="r|*", fileobj=file_object) 


def read_image_content(image_path,file_path):
    '''read_tar_content will read the content of a tar file,
    and return as a bytes array. This is intended for adding content
    of files to the hash, and not the files themselves.
    '''
    cli = Singularity()
    content = cli.execute(image_path,'cat %s' %(file_path))

